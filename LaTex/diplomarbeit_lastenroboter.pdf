      Diplomarbeit:
      Lastenroboter

Höhere Technische Bundeslehranstalt Graz Gösting
                     Schuljahr 2024/25

Diplomanden:     5AHEL  Betreuer:
Daniel Schauer   5AHEL  Prof. DI. Gernot Mörtl
Simon Spari      5AHEL
Felix Hochegger

                 1
Eidesstattliche Erklärung

Wir erklären an Eides statt, dass wir die vorliegende Diplomarbeit selbstständig und ohne
fremde Hilfe verfasst, keine anderen als die angegebenen Quellen und Hilfsmittel benutzt
und die den benutzten Quellen wörtlich und inhaltlich entnommenen Stellen als solche
erkenntlich gemacht haben.

Ort, am TT.MM.JJJJ  Daniel Schauer

                    Simon Spari

                    Felix Hochegger

                                     2
  Danksagung

An dieser Stelle möchten wir unseren aufrichtigen Dank aussprechen.
Ein besonderer Dank gilt Herrn Prof. DI Gernot Mörtl für seine wertvolle Unterstützung,
seine fachliche Begleitung und seine konstruktiven Anregungen während der gesamten
Arbeit. Seine Expertise und sein Engagement haben maßgeblich zum Gelingen dieser
Diplomarbeit beigetragen.
Ebenso danken wir unseren Freunden, insbesondere Michael Johannes Anderhuber, für
seine Unterstützung beim Schweißen des Gehäuses. Sein handwerkliches Geschick und
seine Hilfe waren für die Umsetzung unseres Projekts von großem Wert.
Unser großer Dank gilt zudem unserem großzügigen Sponsor,"Vogl Baumarkt Rosental",
für das Sponsoring des Metalls für das Gehäuse. Durch diese Unterstützung konnten wir
unser Projekt in dieser Form verwirklichen.

                                                                                                          3
Inhaltsverzeichnis

1 Einleitung         7

1.1 Kurzzusammenfassung . . . . . . . . . . . . . . . . . . . . . . . . . . . 7

1.2 Abstract . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8

2 Projektmanagement  9

2.1 Projektteam . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9

2.2 Projektstrukturplan . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10

2.3 Meilensteine . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10

2.4 Kostenaufstellung . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11

3 Antrieb            12

3.1 Motoren . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12

3.1.1 Übersicht . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12

3.1.2 Funktionsweise . . . . . . . . . . . . . . . . . . . . . . . . . . . 12

3.1.3 Technische Daten . . . . . . . . . . . . . . . . . . . . . . . . . . 14

3.2 Motorentreiber . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14

3.2.1 Überblick . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14

3.2.2 Aufbau und Funktionen . . . . . . . . . . . . . . . . . . . . . . 14

3.3 Schaltungsaufbau . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17

3.4 Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17

4 Webserver          18

4.1 Grundlegende Ziele . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18

4.2 Ideen und Entwürfe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19

4.3 Webserver . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19

4.3.1 Webserver Setup . . . . . . . . . . . . . . . . . . . . . . . . . . 19

4.3.2 SPIFFS Setup . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20

4.4 WebSocket Kommunikation . . . . . . . . . . . . . . . . . . . . . . . . 22

4.4.1 Kommunikation Setup . . . . . . . . . . . . . . . . . . . . . . . 22

4.4.2 Message Handling . . . . . . . . . . . . . . . . . . . . . . . . . 24

4.5 Kamera . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28

4.6 Kamera . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28

4.6.1 Kamera Setup . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28

4.7 Videoübertragung . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30

4.8 Website . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31

                     4
      4.8.1 Implementierung der Steuerung . . . . . . . . . . . . . . . . . . 31
      4.8.2 Echtzeit-Videoanzeige . . . . . . . . . . . . . . . . . . . . . . . 42
      4.8.3 Anzeige von Sensordaten und Verbindungsstatus . . . . . . . . . 45
4.9 Herausforderungen und Optimierungen . . . . . . . . . . . . . . . . . . 51
      4.9.1 Probleme bei der WebSocket Kommunikation . . . . . . . . . . . 51
      4.9.2 Latenz- und Performance Optimierungen . . . . . . . . . . . . . 51
      4.9.3 (Speicher- und Rechenleistungseinschränkungen des ESP32) . . . 51
4.10 (Fazit und Ausblick) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
      4.10.1 (Mögliche Erweiterungen und Verbesserungen) . . . . . . . . . . 51

5 Gehäuse            52

5.1 Planung und Design . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52

5.2 Realisierung . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52

5.3 Materialliste . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52

6 Platine            53

6.1 Grundschaltung . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53

6.2 Circuit Board . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53

6.3 Fertiger Prototyp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53

7 Kamera             54

7.1 Kamera im Überblick . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54

7.2 Videoübertragung . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54

7.3 Kameraschwenkung . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54

7.3.1 Gehäuse . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54

7.3.2 Servomotor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54

7.4 Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54

8 Sensoren           55

8.1 Abstandsensor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55

8.2 Gewichtsmessung . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55

8.2.1 Grundprinzip . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55

8.2.2 Schaltungsaufbau . . . . . . . . . . . . . . . . . . . . . . . . . . 55

8.2.3 Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55

9 Entwicklungstools  56

9.1 Autodesk Fushion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56

9.2 Eagle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56

9.3 VS-Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56

                     5
      9.3.1 Setup . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
      9.3.2 Bibliotheken . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
      9.3.3 verwendete Bibliotheken . . . . . . . . . . . . . . . . . . . . . . 57
9.4 LaTex . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
9.5 GitHub . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58

10 Abbildungsverzeichnis  59

11 Literaturverzeichnis   61

                          6
1 Einleitung

1.1 Kurzzusammenfassung

In dieser Diplomarbeit wird ein Lastenroboter entwickelt, der bis zu 25 Kilogramm trans-
portieren kann. Der Roboter wird über eine Website gesteuert, die als Steuerungsplatt-
form dient. Zusätzlich ist eine Kamera eingebaut, die den Transportbereich zeigt, sowie
eine Waage, die das Gewicht der transportierten Last misst.
Ein Schwerpunkt der Arbeit lieg auf der mechanischen Konstruktion des Roboters, bei
der ein stabiles Gehäuse aus Stahl gebaut wird, um Sicherheit und Stabilität zu gewähr-
leisten. Außerdem wird eine eigene Platine entwickelt, die die verschiedenen Hardware-
Komponenten, wie die Sensoren und die Motoren, steuert und miteinander verbindet.
Die Steuerung des Roboters erfolgt über eine Website, die es dem Benutzer ermöglicht,
den Roboter zu bedienen und wichtige Daten wie Akkustand und Gewicht abzurufen. Ein
besonderer Fokus liegt auch dabei auf der Übertragung des Kamerabildes auf die Web-
Oberfläche sowie der Integration einer schwenkbaren Kamera, um eine flexible Sicht auf
den Transportbereich zu gewährleisten. Der ESP32 sorgt dafür, dass die Befehle des Be-
nutzers an den Roboter übermittelt werden.
Zusätzlich wird eine OnBoard-Software entwickelt, die es ermöglicht, die Sensoren aus-
zulesen und die Motoren als auch die Kamera anzusteuern.

                                                                                                          7
1.2 Abstract

This thesis develops a load robot that can carry up to 25 kilograms. The robot is controlled
via a website, which serves as the control platform. Additionally, a camera is integrated
to display the transport area, as well as a scale to measure the weight of the carried load.

A key focus of the work is on the mechanical design of the robot, where a sturdy steel
housing is built to ensure safety and stability. Furthermore, a custom circuit board is de-
veloped to control and connect the various hardware components, such as sensors and
motors.

The robot is controlled via a website, which allows the user to operate the robot and ac-
cess important data such as battery level and weight. A particular focus is also placed on
transferring the camera feed to the web interface and integrating a swivel camera to en-
sure flexible viewing of the transport area. The ESP32 ensures that the user’s commands
are transmitted to the robot.

Additionally, onboard software is developed to read the sensors and control the motors
and camera.

Daniel Schauer - nur als Muster  8
2 Projektmanagement

2.1 Projektteam

                                Betreuer: Prof. DI. Gernot Mörtl

 Abbildung 1:   Daniel Schauer: Software-OnBoard
     Porträt
                    • Projektleiter
Daniel Schauer      • Verbindung von Software und Hardware (ESP32 zu

                       Sensoren)
                    • Kamera-Übertragung zur Web-Oberfläche
                    • Umsetzung einer schwenkbaren Kamera
                    • Dokumentation

Abbildung 2:    Simon Spari: Software-App
   Porträt
                    • Benutzeroberfläche (Web-Oberfläche) für Steue-
Simon Spari            rung

                    • Übertragung der Steuerung/Befehle von Web-
                       Oberfläche zu ESP32

                    • Kamera-Übertragung zur Web-Oberfläche

                    • Dokumentation

                Felix Hochegger: Hardware-Design und Mechanik

                    • Bau des Roboter Gehäuse
                    • Ansteuerung und Verbindung von Hardware (An-

                       steuerung und Berechnung der Motoren)
                    • Dokumentation

Abbildung 3:
Porträt Felix
 Hochegger

Daniel Schauer - nur als Muster                                   9
2.2 Projektstrukturplan

Unsere Diplomarbeit beschäftigt sich mit der Entwicklung eines Lastenroboters. Der Las-
tenroboter soll etwa ein Gewicht von 25 Kilogramm tragen können. Die Steuerung erfolgt
über eine Handy-App, und zusätzlich soll eine Kamera eingebaut werden. Im Lastenrobo-
ter wird auch eine Waage eingebaut, damit man sehen kann, wie schwer die transportierte
Last ist.
Das Ziel dieser Diplomarbeit ist also, ein betriebsbereiter Prototyp eines Lastenroboters
mit Kamerasystem und Waage zu entwickeln und zu realisieren.

Geplantes Ergebnis der individuellen Themenstellungen:
Felix Hochegger: Bau des Roboter-Gehäuses und Integration der Komponenten, Verbin-
dung der Hardware im besonderen Ansteuerung der Motoren
Simon Spari: Entwicklung einer Benutzeroberfläche (Web-Oberfläche) zur Steuerung
des Roboters, Übertragung der Steuerbefehle in Echtzeit an die Hardware
Daniel Schauer: Verbindung von Software und Hardware zur Umsetzung der Steuerbe-
fehle, Kamera-Übertragung in Echtzeit zur GUI, Umsetzung schwenkbare Kamera
Projektstrukturplan: Bild einfügen vom Grundplan.

2.3 Meilensteine

Um unseren Fortschritt und unsere Zeiteinteilung besser im Überblick zu behalten, haben
wir uns bestimmte Meilensteine für unser Projekt gesetzt. Diese sind sehr hilfreich, um
das Projekt strukturiert umzusetzen, angefangen von der Projektplanung bis hin zum fer-
tigen Prototyp.

Die folgenden Meilensteine haben wir uns bei der Projektplanung gesetzt:

Meilenstein                      Datum

Grundlegendes Gehäuse            07.11.2024

Funktionsfähige Website          19.12.2024

Funktionsfähige steuerbare Motoren 16.01.2025

Funktionsfähiger Prototyp        06.03.2025

Daniel Schauer - nur als Muster                                           10
2.4 Kostenaufstellung

Artikel                          Einzelpreis Stückzahl Gesamt

Aufblasbares Rad 10” 260x85      16.70 C              4 66.80 C

MCP23017                         4.54 C               2 9.08 C

PICAA LED Arbeitsscheinwerfer    6.55 C               2 13.10 C

2 Stück PWM Motor Steuerung Treiber Platinen 35.78 C  2 71.56 C

Micro Servo Motor                6.04 C               1 6.04 C

IRM-30-15ST                      17.04 C              1 17.04 C

SOLSUM 0808                      25.17 C              1 25.17 C

Platinen                         37.14 C              1 37.14 C

ESP32 CAM                        13.70 C              1 13.70 C

12 Stück Halbbrücken Wägezelle   11.09 C              1 11.09 C

ESP32                            11.09 C              1 11.09 C

Dunkermotoren                    65.00 C              2 130.00 C

AGM 12V Batterie                 24.80 C              1 24.80 C

Diverse Kleinteile               30.00 C              1 30.00 C

Summe                                                 466.61 C

Daniel Schauer - nur als Muster                       11
3 Antrieb

3.1 Motoren

3.1.1 Übersicht
Für den Antrieb des Lastenroboters werden BLDC-Motoren eingesetzt. Verwendet wer-
den die BLDC-Motoren von Dunkermotoren (Typ BG 40X25). Ein BLDC-Motor auch
bürstenloser Gleichstrommoter gennant wird über drei Phasen betrieben. Der BLDC-
Motor wird oft in der Industrie eingesetzt weil er eine hohe Leistung bietet.

                                        Abbildung 4: Motoren

                                           Quelle: eigene Abbildung

3.1.2 Funktionsweise
Die Funktionsweise eines bürstenlosen Gleichstrommotors basiert auf die Wechselwir-
kung zwischen dem Magnetfeld des Stators und dem Magnetfeld des Rotors.

Stator: Der Stator besteht aus mehreren Spulen, die üblicherweise drei Phasen umfasst.
Die drei Phasen werden mit Wechselstrom angesteuert die dann ein rotierendes Magnet-
feld erzeugen.

Rotor: Der Rotor besteht aus einem Permanentmagneten. Dadurch das die Spulen ein
rotierendes Magnetfeld erzeugen dreht sich der Rotor synchron mit diesem Magnetfeld
mit.

Daniel Schauer - nur als Muster  12
                                     Abbildung 5: BLDC-Motor

                                    Quelle: www.elektrikrehberiniz.com

Damit die Phasen richtig geschalten werden muss man wissen, wo sich der Rotor befindet.
Die genaue Position des Rotors wird durch Hallsensoren erfasst. Die Hallsensoren geben
diese Informationen an die Steuerelektronik weiter. Mit diesen Daten kann die optimale
Beschaltung der Phasen berechnet werden.

Zur Steuerung der Drehzahl wird ein PWM-Signal verwendet. Durch die PWM wird die
Stromzufuhr zu den Phasen des Motors gesteuert. Wenn man die PWM erhöht, werden
die Phasen schneller angesteuert und der Rotor dreht sich schneller. Das heißt durch das
PWM-Signal wird die Versorgungsspannung an den Phasen schnell ein- und ausgeschal-
ten.

Auf diese Weise kann der Motor effizient mit variabler Geschwindigkeit betrieben wer-
den.

                 Abbildung 6: Phasensteuerung

Quelle: davincii.de/arduino-projekte/brushless-motor-ansteuerung

Daniel Schauer - nur als Muster                                   13
3.1.3 Technische Daten

Eigenschaft                      Wert

Spannung                         15V

Rotationsgeschwindigkeit der Antriebswelle 3260 rpm

Max. Strom                       2A

3.2 Motorentreiber

3.2.1 Überblick

Für die Ansteuerung der BLDC-Motoren wird der Motortreiber ZX-X11H verwendet.
Dieser Motortreiber übernimmt die elektronische Kommutierung, das heißt dieser Trei-
ber schaltet die Phasen des Motors damit sich der Rotor dreht. Die Rotorposition wird
über Hallsensoren erfasst. Mit diesen Daten werden die Phasen richtig angesteuert damit
sich der Rotor dreht. Dies ermöglichten einen gleichmäßigen Betrieb sowie eine exakte
Regelung von Drehzahl und Drehmoment. Durch die integrierte PWM-Steuerung kann
die Geschwindigkeit präzise eingestellt werden. Zusätzlich verfügt der ZS-X11H über
eine Richtungssteuerung und Bremse.

3.2.2 Aufbau und Funktionen

                          Abbildung 7: Motorteiber-ZS-X11H

          Quelle: mad-ee.com/easy-inexpensive-hoverboard-motor-controller/g

Daniel Schauer - nur als Muster                                              14
Steuerung der Phasenströme:
    • Der Treiber steuert die drei Motorphasen (MA, MB, MC) mithilfe eines integrierten
       MOSFET-Brückenschaltkreises.
    • Mit den Daten der Hallsensoren schaltet der Treiber die Phasen damit sich der Rotor
       mit der gewünschten Geschwindigkeit dreht.

                              Abbildung 8: Motorphasen Verbindung

                Quelle: mad-ee.com/easy-inexpensive-hoverboard-motor-controller/g

PWM-Steuerung
    • Die PWM steuert die Geschwindigkeit, indem sie die Leistung moduliert, die den
       Motorwicklungen zugeführt wird..
    • Die Amplitude des PWM-Signals muss zwischen 2,5-5 V liegen.
    • Die PWM-Frequenz muss zwischen 50-20 kHz liegen.
    • Die Platine ist ausgestattet mit einer externen und internen PWM-Steuerung.

                   Abbildung 9: Pins für die PWM

Quelle: mad-ee.com/easy-inexpensive-hoverboard-motor-controller/g

Daniel Schauer - nur als Muster                                    15
Richtungswechsel und Bremse
    • Die Platine verfügt über zwei Steuereingänge für Richtungswechsel (DIR) und eine
       Bremsfunktion (BREAKE).
    • Der Richtungswechsel erfolgt, indem das Signal bei dem Eingang von LOW auf
       HIGH oder umgekehrt wechselt. Das Umschalten der Richtung wechselt die Rei-
       henfolge der Phasenströme, wodurch sich dann der Motor in die andere Richtung
       dreht.
    • Die Bremse reagiert auf ein HIGH-Signal. Das heißt wenn am Eingang ein HIGH-
       Signal angelegt wird, stoppt der Motor, indem die Wicklungen kurzgeschlossen
       werden.

                Abbildung 10: Pin für die Bremse und den Richtungswechsel

                Quelle: mad-ee.com/easy-inexpensive-hoverboard-motor-controller/g

Spannungs- und Stromversorgung
    • Der Treiber kann mit einer Versorgungsspannung von 12V-60V betrieben werden,
       wodurch er für eine Vielzahl von BLDC-Motoren geeignet ist.
    • Die maximale Stromaufnahme des Treibers liegt bei zirka 15A.
    • Der Treiber ist für Motoren bis zu 500 Watt geeignet und kann damit leistungsstarke
       Motoren betreiben

                                  Abbildung 11: Versorgungs-Pins

                Quelle: mad-ee.com/easy-inexpensive-hoverboard-motor-controller/g

Daniel Schauer - nur als Muster  16
    Hall-Sensoren
         • Der Treiber verwendet drei Hall-Sensor-Eingänge. (Ha, Hb, Hc)
         • Mit diesen Hall-Sensoren wird die Rotorposition ermittelt damit die Phasen des
           Motors richtig geschaltet werden.
         • Die Sensoren ermöglichen eine effiziente und stabile Steuerung.

                                  Abbildung 12: Hall-sensoren Eingänge

                     Quelle: mad-ee.com/easy-inexpensive-hoverboard-motor-controller/g

Sicherheit und Schutzfunktionen
    • Der Treiber verfügt über einen Überstromschutz und Überspannungsschutz damit
       der Motor und die Elektronik Geschütz ist.
    • Ein thermischer Schutz verhindert Schäden durch Überhitzung.

3.3 Schaltungsaufbau
3.4 Code

Daniel Schauer - nur als Muster  17
4 Webserver

4.1 Grundlegende Ziele

In diesem Kapitel befassen wir uns mit der geplanten Website, die den Benutzern und
Benutzerinnen die Steuerung des Lastenroboters ermöglichen soll. Zuallererst definieren
wir die grundlegenden Funktionen, die die Website erfüllen soll. Sobald diese erfüllt sind,
versuchen wir, das User Interface so einfach und benutzerfreundlich wie möglich zu ge-
stalten. Ein weiterer Punkt ist die Darstellung der spezifischen Messwerte und Daten,
damit diese am Webserver schnell und leicht zugänglich sind.

Für die Entwicklung der Website verwenden wir HTML, CSS und JavaScript, um alle
funktionalen und optischen Anforderungen zu erfüllen.

Videoübertragung
Auf der Website soll eine Echtzeit Videoübertragung der ESP32-CAM angezeigt werden.
Die Bildfrequenz und die Qualität der Videoübertragung sollte ausgeglichen sein, so dass
in der Übertragung alle Objekte und ggf. Hindernisse frühzeitig erkennbar sind und noch
Reaktionszeit zum Manövrieren besteht.

Steuerung
Auf der Website soll eine grafische Steuereinheit implementiert werden, mit der der Ro-
boter gesteuert und navigiert werden kann. Diese soll dann die entsprechenden Steuerbe-
fehle bzw. Richtungen an den ESP32 senden, wo sie dann in Steuerungsbefehle für die
Motoren übersetzt werden.

Anzeigen von Daten
Auf der Website sollen bestimmte Messwerte und Daten, wie zum Beispiel Akkustand
oder zurzeit aufliegende Last, die vom ESP32 durch Sensoren oder Messungen ausgewer-
tet werden, übersichtlich und leicht zugänglich angezeigt werden.

Daniel Schauer - nur als Muster  18
4.2 Ideen und Entwürfe
4.3 Webserver

4.3.1 Webserver Setup
Der Webserver wird mithilfe der Bibliothek ESPAsyncWebServer auf einem ESP32-CAM
Mikrocontroller eingerichtet. Diese Bibliothek ermöglicht einen nicht-blockierenden Be-
trieb, wodurch parallele Anfragen effizient verarbeitet werden können.1

                      Abbildung 13: ESPAsyncWebServer.h-Bibliothek

                                           Quelle: eigene Abbildung

Für die Netzwerkkonfiguration wurde ein eigener Access Point mit folgenden Parametern
definiert:

    • SSID (Service Set Identifiert) : “Carybot” – dient zur Identifikation des drahtlosen
       Netwerkes

    • Passwort: “123456789“ – dient zum Schutz des Netwerkes
    • Lokale IP-Adresse: 192.168.4.1 – dient zum Zugriff auf die Webserver-Oberfläche
    • Gateway-Adresse: 192.168.4.1 - ESP32-CAM fungiert als Access Point
    • Subnetzmaske: 255.255.255.0 - ermöglicht die Kommunikation zwischen Geräten

       im Bereich 192.168.4.x

Der Webserver wird auf Port 80 erstellt. Port 80 ist der Standardport für HTTP-Dienste.

                    Abbildung 14: WebServer Netzwerkkonfiguration

                                       Quelle: eigene Abbildung

1https://github.com/lacamera/ESPAsyncWebServer

Daniel Schauer - nur als Muster                                    19
In der Setup Funktion wird danach überprüft, ob der Access Point erfolgreich konfiguriert
worden ist und ob der Access Point erfolgreich gestartet werden kann. Falls ein Fehler
auftreten sollte, wird der Setup unterbrochen und die jeweilige Fehlermeldung in der seri-
ellen Konsole ausgegeben. Wenn alles erfolgreich konfiguriert ist und starten kann, wird
im Seriellen Monitor die IP-Adresse in der seriellen Konsole ausgegeben. Anschließend
wird der Webserver gestartet.

Abbildung 15: Webserver Setup

     Quelle: eigene Abbildung

4.3.2 SPIFFS Setup

SPIFFS (SPI Flash File System) ist ein leichtgewichtiges Dateisystem für Mikrocontroller
mit SPI-Flash-Speicher. Es ermöglicht das Speichern und Verwalten von Dateien direkt
im Flash-Speicher des Mikrocontrollers. SPIFFS wird in unserem Projekt benötigt, um
statische Dateien für unseren Webserver (HTML-, CSS-, JavaScript Anwendungen) be-
reitzustellen.

In unserem Code wird zuallererst einmal überprüft, ob SPIFFS beim Start der ESP32-
CAM richtig initialisiert werden kann. Falls es fehlschlägt, wird eine Fehlermeldung in
der seriellen Konsole ausgegeben und das Programm gestoppt. Ansonsten werden die
Webserver-Endpunkte über HTTP-GET-Routen definiert, über die unsere statischen Da-

Daniel Schauer - nur als Muster  20
teien aus SPIFFS an Clients gesendet werden.

“/“ ist die Standardroute des Servers. Somit wird dpad.html als Startseite angezeigt, wenn
ein Client sich verbindet.

“menu-icon.svg“ und “Fernlicht.svg“ werden als SVG-Bilder (Scalable Vector Graphics)
an den Browser gesendet. Image/svg+xml sorgt dafür, dass der Browser die Dateien als
SVG-Bilder erkennt.

“mystyles.css“ wird mit text/css als CSS-Datei gesendet und dient zur Formatierung der
Website.

“carybot.js“ wird mit application/javascript als Javascript-Datei gesendet und verarbeitet
die Eingaben von Clients auf der Website.

Wenn alle Dateien erfolgreich geladen sind, wird eine Nachricht in der seriellen Konsole
ausgegeben.

Abbildung 16: SPIFFS Initalisierung

        Quelle: eigene Abbildung

Daniel Schauer - nur als Muster      21
Die readFile() Funktion wird benötigt, um die jeweiligen Dateien aus SPIFFS lesen zu
können. Die Funktion liest eine Datei aus dem SPIFFS-Speicher und gibt den Inhalt als
String zurück.

                              Abbildung 17: readfile()-Funktion

                                           Quelle: eigene Abbildung

4.4 WebSocket Kommunikation

4.4.1 Kommunikation Setup
Für die Kommunikation zwischen dem Webserver und dem ESP32 wird die ArduinoJson
und die ArduinoWebSockets Bibliothek benötigt. Die ArduinoJson Bibliothek wird für
die Umwandlung der JSON-Steuerbefehle benötigt. Die ArduinoWebSockets Bibliothek
wird für die Kommunikation über das WebSocket Protokoll benötigt.

                                Abbildung 18: Bibliotheken für die
                                            Kommunikation

                                           Quelle: eigene Abbildung

Daniel Schauer - nur als Muster  22
    Für die Netzwerkkonfiguration als Client werden folgenden Parameter definiert:
    • SSID: “Carybot“ – gleiche SSID wie ESP32-CAM
    • Passwort: “123456789“ – gleiches Passwort wie ESP32-CAM
    • Lokale IP-Adresse: 192.168.4.3
    • Gateway-Adresse: 192.168.4.1 – Adresse des Access Points (ESP32-CAM)
    • Subnetzmaske: 255.255.255.0 – ermöglicht Kommunikation zwischen Geräten im

       Bereich 192.168.4.x
Für die WebSocket-Kommunkation wurde der Port 8080 gewählt.

                          Abbildung 19: Netzwerkkonfiguration Client

                                           Quelle: eigene Abbildung

In der Setup Funktion des Programmes wird dann überprüft, ob die IP-Konfiguration er-
folgreich abgeschlossen wurde. Ansonsten kommt es zu einer Fehlermeldung und das
Setup wird abgebrochen. Danach wird versucht, sich mit dem WLAN-Netzwerk zu ver-
binden. Wenn sich der ESP32 erfolgreich mit dem WLAN verbunden hat, wird eine Nach-
richt und die IP-Adresse des ESP32 in der seriellen Konsole ausgegeben. Danach wird
die WebSocket Konfiguration noch gestartet. Es wird definiert, dass die Funktion onWeb-
SocketEvent aufgerufen wird, wenn Events über den WebSocket registriert werden. In der
loop Funktion wird dann noch ständig überprüft, ob neue Events am WebSocket registriert
werden.

Daniel Schauer - nur als Muster  23
                     Abbildung 20: Setup ESP32

                        Quelle: eigene Abbildung

4.4.2 Message Handling

In der Funktion onWebSocketEvent() werden die WebSocket-Ereignisse verarbeitet. Sie
wird aufgerufen, wenn sich ein WebSocket-Client verbindent, eine Nachricht sendet oder
die Verbindung sich trennt. Der Parameter num steht für die ID des Clients, der das Event
ausgelöst hat. Der Parameter type gibt die Art des WebSocket-Event an. Der Parame-
ter payload sind die empfangenen Daten. Der Parameter length steht für die Größe des
payload-Arrays. In der Funktion werden die Events mit einem switch-case verarbeitet

Übersicht der WebSocket-Ereignisse:

Ereignistyp          Beschreibung                   Verarbeitung
WStype_CONNECTED
WStype_TEXT          Ein neuer Client verbindet     Ausgabe der Client-ID & IP-
WStype_BIN           sich.                          Adresse in der Konsole
WStype_DISCONNECTED
                     Eine Textnachricht wird emp-   Übergabe                  an
                     fangen.
                                                    handleWebSocketMessage()
                     Binärdaten werden empfan-
                     gen.                           Nachricht in der Konsole (wird
                                                    nicht verarbeitet)
                     Ein Client trennt die Verbin-
                     dung.                          Meldung mit der Client-ID in der
                                                    Konsole.

Tabelle 3: Übersicht der WebSocket-Ereignisse

Daniel Schauer - nur als Muster                                               24
                        Abbildung 21: onWebSocketEvent()-Funktion

                                           Quelle: eigene Abbildung

Die Funktion handleWebSocketMessage() verarbeitet die WebSocket-Nachricht, die als
JSON-Objekte gesendet werden. Die Parameter sind wieder die Client-ID, die empfange-
nen Nachricht und die Länge der empfangenen Nachricht.

Zuerst wird die empfangene Nachricht (payload) in einen String konvertiert. Diese wird
dann in der seriellen Konsole ausgegeben. Danach wird ein JSON-Dokument mit max
200 Bytes erstellt. Die empfangene Nachricht wird dann mit deserialzeJson() geparst.
Falls das Parsen erfolgreich war, wird die JSON-Nachricht verarbeitet.

Wenn die JSON-Nachricht den Namen robot_direction enthält, wird die Richtung mit
der Funktion stringToDirection() in eine eigene Variable umgewandelt. Auch die
mitgesendete Variable speed wird ebenfalls in eine eigene Variable gespeichert.

Abbildung 22: JSON-Beispiel für
              Steuerung

      Quelle: eigene Abbildung

Daniel Schauer - nur als Muster  25
Wenn die JSON-Nachricht den Namen camera_position enthält, wird der Wert der
Nachricht in die Variable camera_pos gespeichert und die Funktion cam_turn() auf-
gerufen.

                                 Abbildung 23: JSON-Beispiel für
                                           Kamerasteuerung

                                           Quelle: eigene Abbildung

Wenn die JSON-Nachricht den Namen light_status enthält, wird der Wert der Nach-
richt in die boolesche Variable light_status gespeichert. Dieser Variable wird dann in
die numerische Variable light_st umgewandelt (1 = an, 0 = aus). Wenn light_st eine 1
ist, wird die Funktion lights_on() aufgerufen, ansonsten wird die Funktion lights_off()
aufgerufen.

                                   Abbildung 24: JSON-Beispiel
                                          für Lichtsteuerung

                                           Quelle: eigene Abbildung

Daniel Schauer - nur als Muster  26
Abbildung 25: handleWebSocketMessage()-Funktion

                     Quelle: eigene Abbildung

Daniel Schauer - nur als Muster                  27
4.5 Kamera

4.6 Kamera

4.6.1 Kamera Setup

Um die Kamera programmieren zu können, muss zunächst das richtige Board AI Thinker
ESP32-CAM ausgewählt werden. Danach müssen die ESP32-Kamera-Treiber mit der Bi-
bliothek esp_camera.h inkludiert werden. Dann muss das passende ESP32-CAM-Modell
festgelegt werden. Da wir uns für das Ai-Thinker Modell entschieden haben, muss diese
nun definiert werden. Falls ein anderes Modell genutzt wird, muss es entsprechend ange-
passt werden.

Als nächstes werden die GPIO-Pins der ESP32-CAM für die Kamera OV2640 konfi-
guriert. Diese Zuordnung ist spezifisch für das Ai-Thinker-Modell und muss für jedes
Modell individuell angepasst werden.

Abbildung 26: Kamera-GPIO Konfiguration

             Quelle: eigene Abbildung

Daniel Schauer - nur als Muster          28
Als nächstes muss die ESP32-CAM mit der ESP-IDF esp_camera Bibliothek konfigu-
riert und initialisiert werden. Als erstes muss mit camera_config_t eine Struktur defi-
niert werden, mit der verschiedene Parameter und Eigenschaften wie GPIO-Pins, Bild-
größe und Qualität festlegt werden können.

LEDC-Kanal und Timer werden für das Taktsignal benötigt, um die Kamera zu betreiben.

Zum Schluss wird die Kamera mit den konfigurierten Einstellungen initialisiert. Falls bei
der Initialisierung ein Fehler auftreten soll, wird dieser in der seriellen Konsole ausgege-
ben und das Setup abgebrochen.

Abbildung 27: Kamera-Initialisierung

         Quelle: eigene Abbildung

Daniel Schauer - nur als Muster       29
4.7 Videoübertragung

In unserem Projekt werden die Live-Bilder per WebSocket an den Webserver gesen-
det. Um dies umzusetzen, wird zuerst eine Webserver-Route benötigt. Dazu wird ei-
ne http-GET-Anfrage für die Hauptseite (“/“) definiert. Im Code wird ein JavaScript
Skript benutzt, um eine Websocket-Verbindung herzustellen. Die IP-Adresse wird auto-
matisch durch windows.location.hostname erkannt. Port 81 wird für das WebSocket-
Streaming verwendet. Wenn die ESP32-CAM ein neues Bild als WebSocket-Nachricht
versendet, wird es als JPEG-Blob gespeichert. Danach wird ein temporär URL-Link er-
stellt. Das Bild wird schlussendlich in einem <img>-Tag mit der id stream angezeigt.

Die WebSocket Verbindung wird die ganze Zeit überwacht. In der Konsole wird ausge-
geben, wenn die Websocket-Verbindung aktiv ist. Falls die Verbindung abbrechen soll-
te, wird nach 5 Sekunden automatisch ein erneuter Verbindungsversuch gestartet. Zum
Schluss wird der HTML-Code mit HTTP-Status 200 (OK) an den Browser gesendet.

Abbildung 28: Videoübertragung über WebSocket

                 Quelle: eigene Abbildung

Daniel Schauer - nur als Muster                30
4.8 Website

4.8.1 Implementierung der Steuerung

Steuerkreuz

Um den Roboter überhaupt steuern zu können, wird ein Steuerkreuz implementiert. Das
Steuerkreuz befindet sich mittig am rechten Bildschirmrand. Das Steuerkreuz besteht aus
fünf Tasten, nämlich: Vorwarts (UP), (DOWN ), links (LEFT), rechts (RIGHT) und in der Mit-
te Stop (HALT).

                           Abbildung 29: Steuerkreuz auf der Website

                                           Quelle: eigene Abbildung

Im HTML-Code wird das Steuerkreuz als HTML <div>-Tag im body Bereich definiert.
Für die Formatierung wird die CSS-Klasse dpad-container verwendet. Die einzelnen
Richtungstasten des Steuerkreuze werden auch als HTML <div>-Tags definiert. Jede Tas-
te wird mit der CSS-Klasse button und der jeweiligen Zusatzklasse up/down/left/right/center
formatiert. Beim jeweiligen Tastendruck wird außerdem immer das Attribut data-direction
mit der jeweiligen Richtung belegt.

Abbildung 30: Steuerkreuz HTML-Code

           Quelle: eigene Abbildung

Daniel Schauer - nur als Muster      31
Die CSS-Klasse dpad-container ist das übergeordnete Element, welches die Steu-
erkreuztasten enthalten. Es wird als CSS Grid mit einer 3x3 Struktur definiert. Es gibt
Lücken (.) an den Ecken, damit das Layout wie ein Steuerkreuz aussieht. Der Abstand
zwischen den Tasten wird mit 10px festgelegt. Der Container hat eine feste Breite von
120px und ist vertikal so wie horizontal zentriert.

Die CSS-Klasse button sorgt für eine einheitliche Gestaltung der Tasten des Steuerkreu-
zes. Jede Taste hat eine Größe von 60x60px. Eine Flexbox wird verwendet, um die Tasten
jeweils mittig in den einzelnen Positionen des Grids zu positionieren. Jede Taste hat einen
dunkelgrauen Hintergrund, eine weiße Textfarbe, einen 2px dicken dunklen Rahmen und
abgerundete Ecken. Die Optionen -webkit-tap-highlight-color: transparent und
user-select: none sorgen dafür, dass auf mobilen Geräten der Text in den Tasten nicht
blau markiert werden kann, damit die Steuerung nicht blockiert wird.

Abbildung 31: CSS-Klassen .dpad-container
                    und .button

                Quelle: eigene Abbildung

Daniel Schauer - nur als Muster            32
Die fünf Richtungsklassen sorgen dafür, dass die Tasten des Steuerkreuzes in den zuvor
definierten Grid-Bereichen zugewiesen und richtig platziert werden. Die mittlere Taste
bekommt außerdem eine leicht hellere Farbe zugewiesen, um ihn optisch von den ande-
ren abzuheben.

Außerdem bekommen alle Tasten einen Hover-Effekt, damit sie etwas heller werden,
wenn eine Taste gedrückt wird.

                              Abbildung 32: CSS-Richtungsklassen

                                           Quelle: eigene Abbildung

Im JavaScript-Code sorgen zwei EventListener dafür, dass die Elemente auf der Seite
nicht ziehbar und verschiebbar sind und dass das Rechtsklick-Menü nicht geöffnet wer-
den kann. Diese Maßnahmen verhindern unerwünschte Benutzerinteraktionen und sorgen
für eine reibungslose Bedienung.

Daniel Schauer - nur als Muster  33
                    Abbildung 33: <hier gute Bildbeschreibung einfügen>

                                           Quelle: eigene Abbildung

Vier weitere EventListener kümmern sich um die Eingabe des Steuerkreuzes. Es wird
zuerst jeder mousedown (Linksklick) bzw. ein touchstart (klick auf mobile Geräte) ab-
gefangen. Danach wird überprüft, ob das geklickte Element innerhalb eines .button Ele-
ments (Steuerkreuztaste) liegt. Falls ja, wird die Richtung aus dem data-direction-Attribut
gelesen und an die send() Funktion übergeben. Wenn ein mouseup (Maus loslassen) oder
ein touchend (Finger loslassen) abgefangen wird, wird die Funktion stop() aufgerufen.

Abbildung 34: <hier gute Bildbeschreibung
                    einfügen>

             Quelle: eigene Abbildung

Daniel Schauer - nur als Muster            34
Die JavaScript Funktion send() kümmert sich um das Senden der Steuerungsbefehle.
Zuerst wird überprüft, ob die aktuelle Richtung nicht bereits die gewünschte Richtung ist.
Falls ja, wird ein JSON-Objekt erstellt, welche die Richtung sowie die Geschwindigkeit
enthält. Zu debug-Zwecken wird die Richtung sowie die Geschwindigkeit in der Web-
konsole ausgegeben. Danach wird überprüft, ob die WebSocket-Verbindung zur ESP32-
CAM offen ist. Wenn ja, wird die Nachricht auch für debug-Zwecken an die ESP32-
CAM gesendet, ansonsten wird eine Fehlermeldung ausgegeben. Dasselbe geschieht für
die WebSocket-Verbindung zum ESP32. Dort werden jedoch die Steuerbefehle weiterver-
arbeitet.

                                 Abbildung 35: send()-Funktion

                                           Quelle: eigene Abbildung

Die JavaScript Funktion stop() sorgt dafür, dass der Roboter anhält, wenn eine Tas-
te des Steuerkreuzes losgelassen wird. Zuerst wird überprüft, ob die aktuelle Richtung
nicht bereits HALT ist, ansonsten wird sie daraufgesetzt. Danach wird ein Stopp-Befehl
als JSON-Nachricht vorbereitet. Zu debug-Zwecken wird wieder ein halt in der Webkon-
sole ausgegeben. Danach wird der Stopp-Befehl wieder an die WebSocket-Verbindung
zur ESP32-CAM für debug-Zwecke gesendet. Danach wird sie auch an die WebSocket-
Verbindung zum ESP32 gesendet, wo dieser weiterverarbeitet wird.

Daniel Schauer - nur als Muster  35
                                 Abbildung 36: stop()-Funktion

                                           Quelle: eigene Abbildung

Geschwindigkeitseinstellung

Um die Fortbewegungsgeschwindigkeit des Roboters kontrollieren zu können, gibt es auf
der linken Seite neben dem Steuerkreuz einen vertikalen Geschwindigkeitsslider, mit der
die Geschwindigkeit der Motoren gesteuert werden kann. Wenn der Slider nach oben ge-
zogen wird, beschleunigt der Roboter, wenn der Slider nach unten gezogen wird, wird die
Geschwindigkeit verlangsamt.

Abbildung 37: Geschwindigkeitssteuerung auf der Website

                       Quelle: eigene Abbildung

Daniel Schauer - nur als Muster                          36
Im HTML-Code wird mit der CSS-Klasse slider-container ein Bereich im Hauptbe-
reich definiert. Der Slider wird als HTML <input>-Tag mit dem type range von 0 bis
100 definiert. Für das Design wird die CSS-Klasse slider verwendet und beim Verschie-
ben des Sliders wird die JavaScript Funktion speed_change() mit der aktuellen Position
des Sliders aufgerufen.

                   Abbildung 38: Geschwindigkeitssteuerung HTML-Code

                                           Quelle: eigene Abbildung

In der CSS-Klasse slider-container wird ein Bereich mit der Größe 50x220 Pixel de-
finiert, in dem der Slider angezeigt werden soll. In slider wird definiert, dass der Slider
vertikal und nicht horizontal angezeigt wird. Außerdem wird die Richtung auf Right to
Left gesetzt, damit die aktuelle Position richtig erhöht bzw. vermindert bei Auf- und Nie-
derschieben des Sliders wird.

Abbildung 39: CSS-Klassen für die
    Geschwindigkeitssteuerung

       Quelle: eigene Abbildung

Daniel Schauer - nur als Muster    37
Im JavaScript-Code wird die aktuelle Position des Sliders in die eigene Variable speed
gespeichert. Die Geschwindigkeit wird immer bei einem Steuerbefehl des Steuerkreuzes
mitübertragen. (siehe Steuerkreuz 36)

                           Abbildung 40: speed-change()-Funktion

                                           Quelle: eigene Abbildung

Kamerasteuerung
Um mit der Videoübertragung besser Objekte und Hindernisse zu erkennen, ist die Ka-
mera leicht schwenkbar. Um nun die Kamera auf unserer Website bewegen zu können,
gibt es auf der linken Seite einen horizontalen Slider, mit der die Kamera ein Stück links
und rechts geschwenkt werden kann.

Abbildung 41: Kamerasteuerung auf der Website

                Quelle: eigene Abbildung

Im HTML-Code wird ein mit der CSS-Klasse camera-container ein Bereich im Haupt-
bereich definiert. Der Slider wird als HTML <input>-Tag mit dem type range von 0 bis
180 definiert. Für das Design wird die CSS-Klasse cam_slider verwendet und beim Ver-
schieben des Sliders wird die JavaScript Funktion camera_change() mit der aktuellen
Position des Sliders aufgerufen.

Daniel Schauer - nur als Muster                38
                         Abbildung 42: Kamerasteuerung HTML-Code

                                           Quelle: eigene Abbildung

In der CSS-Klasse camera-container wird ein Bereich erstellt, in dem der Slider an-
gezeigt werden soll. In cam_slider wird die Slidespur mit einer Breite von 150 Pixel
und einer Höhe von 10 Pixel definiert. Der Hintergrund ist hellgrau und die Ecken wer-
den leicht abgerundet. In webkit-slider-thumb wird der Sliderknopf mit 20x20 Pixel
definiert. Der Hintergrund ist dunkelgrau mit einem 2px breiten, dunkleren Rand.

Abbildung 43: CSS-Klassen für die
          Kamerasteuerung

       Quelle: eigene Abbildung

Daniel Schauer - nur als Muster    39
Im JavaScript-Code wird die aktuelle Position des Sliders verarbeitet. Dazu wird die Po-
sition in eine JSON-Nachricht gespeichert. Zu debug-Zwecken wird die Position noch in
der Website Konsole ausgegeben. Wenn der WebSocket Verbindung zum ESP32 offen ist,
wird die aktuelle Position übermittelt.

                          Abbildung 44: camera-change()-Funktion

                                           Quelle: eigene Abbildung

Fernlicht

Die Funktion des Fernlichts dient bei unserem Roboter zur Beleuchtung bei schlechter
Sicht bzw. Dunkelheit. Wenn eingeschalten, leuchtet auf der Vorder- sowie auf der Hin-
terseite des Roboters ein Scheinwerfer die Umgebung aus.

Um das Fernlicht auf unserer Website ein- bzw. auszuschalten gibt es ein eigenes Fernlicht-
Icon rechts über dem Steuerkreuz. Im ausgeschalteten Zustand ist das Icon ausgegraut. Im
aktiven Zustand ist das Scheinwerfer Symbol im Icon blau und das Icon hat einen blass-
grünen Hintergrund.

Abbildung 45: Fernlicht-Icon auf der Website

              Quelle: eigene Abbildung

Daniel Schauer - nur als Muster               40
Im HTML-Code wird das Icon als HTML <img>-Tag eingefügt. Als Quelle wird die
im SPIFFS hochgeladene Fernlicht.svg Grafik verwendet. Für das Design wird die
CSS-Klasse fernlicht-icon verwendet und beim onclick Event wird die JavaScript
Funktion togglelight() aufgerufen.

                            Abbildung 46: HTML-Code für Fernlicht

                                           Quelle: eigene Abbildung

In der CSS-Klasse fernlicht-icon wird das Icon 20% vom oberen Rand und 2% von
rechten Rand mit einer Größe von 50x50 Pixel positioniert. Es wird auf der 2 z-Ebene
angezeigt und der nicht sichtbare Hintergrund wird transparent angezeigt. Beim Ändern
der Farbe wird eine sanfte Animation über 0,3 Sekunden angezeigt.

Die grayscale Klasse wandelt das Icon in die ausgegraute Darstellung um, um anzuzei-
gen, dass das Fernlicht deaktiviert ist. Die active-light Klasse ändert die Hintergrund-
farbe zu einem transparenten grünen Ton, um anzuzeigen, dass das Fernlicht aktiv ist.

Abbildung 47: CSS-Klassen für das Fernlicht

              Quelle: eigene Abbildung

Daniel Schauer - nur als Muster              41
Im JavaScript Code wird bei jedem onclick Event die Variable light getoggled. Wenn
die Variable light true ist, wird die CSS-Klasse active-light angewendet, ansonsten
die CSS-Klasse grayscale. Anschließend wird eine JSON-Nachricht mit dem aktuellen
Zustand der light Variable erstellt. Wenn die WebSocket Verbindung zum zum ESP32
offen ist, wird die JSON-Nachricht versendet, ansonsten wird eine Fehlermeldung ausge-
geben.

                           Abbildung 48: togglelight()-Funktion

                                           Quelle: eigene Abbildung

4.8.2 Echtzeit-Videoanzeige
Die Videoübertragung dient dazu, den Roboter über größere Entfernungen autonom steu-
ern zu können. Mit der Videoübertragung werden Objekte und Hindernisse erkennbar und
kann diese somit ausweichen.

Die Videoübertragung wird über der ganzen Website im Hintergrund angezeigt.

Daniel Schauer - nur als Muster  42
                       Abbildung 49: Videoübertragung auf der Website

                                           Quelle: eigene Abbildung

Im HTML-Code wird die Videoübertragung als HTML <img>-Tag mit der id dynamicimage
im Hauptbereich definiert.

                         Abbildung 50: Videoübertragung HTML-Code

                                           Quelle: eigene Abbildung

Im CSS-Code wird nun das Element mit der id dynamicimage formatiert. Es wird defi-
niert, dass die Größe 100% der Breite sowie 100% der Höhe einnimmt. Die Position wird
dabei auf absolut gesetzt.

Abbildung 51: CSS-Formatierung für
             dynamicimage

         Quelle: eigene Abbildung

Daniel Schauer - nur als Muster     43
Im JavaScript-Code wird die WebSocket-Verbindung zur ESP32-CAM gehandelt. In der
Funktion connectWebSocket_cam() wird zuerst ein WebSocket mit der eigenen IP-
Adresse erstellt (da Webserver auf ESP32-CAM gehostet wird) und dem Port 81 erstellt.
Wenn nun eine Nachricht auf der WebSockte-Verbindung ankommt (siehe Videoübertra-
gung 4.7) wird diese extrahiert. Das mitgesendete BLOB wird in einem neuem BLOB
als jpeg-Bild gespeichert. Danach wird eine URL (Adresse) erstellt, die zu diesem BLOB
führt. Dann wird eine Variable für die Videoübertragung im HTML <img>-Tag erstellt.
Die Source dieses Bildes wird dann mit dem neuen, erhaltenen Bild ersetzt. Da die ESP32-
CAM die ganze Zeit neue Blobs sendet, wird das Bild die ganze Zeit ersetzt, was dazu
führt, dass es aussieht, als wäre es ein Video.

Wenn sich die ESP32-CAM verbindet, wird zu Debug-Zwecken eine Nachricht in der
Webkonsole ausgegeben.

Wenn die Verbindung zur ESP32-CAM verloren geht, wird wieder zu Debug-Zwecke ei-
ne Nachricht in der Webkonsole ausgegeben und ein neuer Verbindungsversuch wird nach
5 Sekunden gestartet.

Abbildung 52: Videoübertragung im JavaScript-Code

                   Quelle: eigene Abbildung

Daniel Schauer - nur als Muster                    44
4.8.3 Anzeige von Sensordaten und Verbindungsstatus
Sensordaten
In der linken oberen Ecke der Website befindet sich das Menü-icon. Ein Klick darauf ruft
die Sidebar für die Daten auf. Die Sidebar klappt sich am linken Bildschirmrand auf. Dar-
in kann ist der aktuelle Akkustand sowie das aktuelle aufliegende Gewicht auslesbar. Um
das Menü wieder schließen zu können, ist ein erneuter Klick auf das Icon erforderlich und
die Sidebar wird wieder zugeklappt.

                            Abbildung 53: Menü-Icon auf der Website

                                           Quelle: eigene Abbildung

Abbildung 54: Sidebar mit Sensordaten

          Quelle: eigene Abbildung

Daniel Schauer - nur als Muster        45
Im HTML-Code wird im Body-Bereich wird das Icon als HTML <img>-Tag eingefügt.
Als Quelle wird die im SPIFFS hochgeladene Grafik menu-icon.svg Grafik verwendet.
Für das Design wird die CSS-Klasse menu-icon verwendet und beim onclick Event wird
die JavaScript Funktion togglemenu() aufgerufen.
Im HTML <div>-Tag werden die einzelnen Daten festgelegt und mir der CSS-Klasse
mymenu formatiert. Das Gewicht und der Akkustand werden als HTML <p>-Tag ange-
zeigt und mit der CSS-Klasse daten formatiert.

                            Abbildung 55: Sensordaten HTML-Code

                                           Quelle: eigene Abbildung

In der CSS-Klasse mymenu wird die sidebar formatiert. Das Menü ist fixiert und nimmt
100% der Höhe ein. Die Anfängliche ist 0, da es versteckt bzw. eingeklappt ist. Die Hin-
tergrundfarbe ist schwarz und es befindet sich auf der z-Ebene 1 um den Hauptinhalt
überdecken zu können. Beim Ein- und Ausblenden dauert 0.5 Sekunden, um einen sanf-
ten Übergang zu ermöglichen.

Der Hautinhalt #main hat eine Animation, damit er beim Öffnen des Menüs nach rechts
verschoben werden kann.

Falls der Bildschirm kleiner als 450px Höhe hat, werden die Abstände der angezeigten
Daten verkleinert. Das dient dazu, um besonders auf Handys die Ansicht zu optimieren.

Die CSS-Klasse menu-icon positioniert das Icon in der linken oberen Ecke mit einer
30x30px Format. Cursor: pointer sorgt dafür, dass das Icon anklickbar ist.

Daniel Schauer - nur als Muster  46
                            Abbildung 56: CSS-Klassen für das Menü

                                           Quelle: eigene Abbildung

Die CSS-Klasse daten formatiert die einzelnen Daten im Menü. Sie werden in der Schrift-
art Arial, Helvetica oder sans-serif angezeigt und in der Farbe Weiß, mit der Schriftgröße
1.2em (20% größer) mittig angezeigt.

Daniel Schauer - nur als Muster  47
                               Abbildung 57: CSS-Klasse .daten

                                           Quelle: eigene Abbildung

In der JavaScript Funktion connectWebSocket_carybot() wird im onmessage()-event
die übertragenen Daten verarbeitet. Für debug-Zwecken werden die angekommen Da-
ten in der WebKonsole ausgegeben. Danach werden die JSON-Nachrichten extrahiert.
Wenn die Nachricht den Akkustand beinhaltet, wird dieser im HTML <p>-Tag mit der id
Akkustand im Menü angezeigt. Wenn die Nachricht das Gewicht beinhaltet, wird dieses
im HTML <p>-Tag mit der id Gewicht im Menü angezeigt. Falls beim Umwandeln ein
Fehler auftreten sollte, wird dieser in der Webkonsole ausgegeben.

                    Abbildung 58: JavaScript-Verarbeitung der Sensordaten

                                           Quelle: eigene Abbildung

Verbindungsstatus
In der WebSocket Status-Box wird der aktuelle Verbindungszustand zum ESP32 ange-
zeigt. Wenn keine Verbindung vorhanden ist, ist die Box rot. Wenn die Verbindung erfolgt,
wird die Box grün.

Daniel Schauer - nur als Muster  48
Abbildung 59: Statusbox auf der Website

           Quelle: eigene Abbildung

Abbildung 60: Statusbox:         Abbildung 61: Statusbox:
         Verbunden                  Verbindung getrennt

    Im HTML-Code wird die Status-Box als HTML <span>-Tag definiert. Für das Design
wird die CSS-Klasse status-box kombiniert je nach Verbindungsstatus mit der Klasse
connected oder disconnected.

                              Abbildung 62: Statusbox HTML-Code

                                           Quelle: eigene Abbildung

In der CSS-Klasse status-box wird die grundlegende Box am linken oberen Bildschirm-
rand positioniert. Die Box liegt auf der zweiten z-Ebene. Die Schrift wird weiß defi-
niert und wird fett dargestellt. Wenn eine Verbindung hergestellt wurde, wird der Hinter-
grund auf grün festgelegt (status-box.connected), ansonsten ist der Hintergrund rot
(status-box.disconnected).

Daniel Schauer - nur als Muster                            49
                                Abbildung 63: CSS-Klassen für die
                                               Statusbox

                                           Quelle: eigene Abbildung

Im JavaScript-Code werden die onopen() und onclose() Events der WebSocket Ver-
bindung gehandelt. Bei einem Verbindungsaufbau (onopen()) wird die Status-Box grün
und der Text wechselt zu Connected. Außerdem wird eine Nachricht für Debug-Zwecke
ausgegeben. Bei einem Verbindungsabbruch wird die Status-Box wieder rot und der Text
wechselt zu Disconnected. Es wird automatisch alle 5 Sekunden ein neuer Versuch zur
Verbindungsaufbau gestartet.

Abbildung 64: JavaScript Funktionen für den Verbindungsstatus

                          Quelle: eigene Abbildung

Daniel Schauer - nur als Muster                                50
4.9 Herausforderungen und Optimierungen

4.9.1 Probleme bei der WebSocket Kommunikation
4.9.2 Latenz- und Performance Optimierungen
Kameraoptimierungen
Als Bildformat wird JPEG verwendet, um Speicherplatz zu sparen. Alternativ wäre RGB565
oder YUV422 möglich, aber diese benötigen mehr Speicher da sie nicht komprimiert sind
und sind somit langsamer zum Übertragen.

Für die Bildauflösung wird QVGA (320x240 Pixel) definiert. Alternativ wären noch VGA
(640x480), SVGA (800x600) oder UXGA (1600x1200) möglich, jedoch brauchen diese
mehr Speicher und mehr Bandbreite und sind somit langsamer zum Übertragen.

Den Wert für die Bildqualität kann von 0 (= beste Qualität) bis 63 (= schlechteste Quali-
tät) definiert werden. Wir definierten die Bildqualität mit 12, was ein guter Kompromiss
zwischen Qualität und Speicherverbrauch ist.

Wir wählten für die Anzahl der Framebuffer 3. Die Anzahl sagt aus, wie viele Bilder
gleichzeitig gespeichert werden können. Mehr Framebuffer erhöhen die Bildrate, benöti-
gen jedoch mehr RAM. (siehe Kamera-Initialisierung) 27

4.9.3 (Speicher- und Rechenleistungseinschränkungen des ESP32)

4.10 (Fazit und Ausblick)

4.10.1 (Mögliche Erweiterungen und Verbesserungen)

Daniel Schauer - nur als Muster  51
5 Gehäuse

5.1 Planung und Design
5.2 Realisierung
5.3 Materialliste

Daniel Schauer - nur als Muster  52
6 Platine

6.1 Grundschaltung
6.2 Circuit Board
6.3 Fertiger Prototyp

Daniel Schauer - nur als Muster  53
7 Kamera

7.1 Kamera im Überblick
7.2 Videoübertragung
7.3 Kameraschwenkung

7.3.1 Gehäuse
7.3.2 Servomotor

7.4 Code

Daniel Schauer - nur als Muster  54
8 Sensoren

8.1 Abstandsensor
8.2 Gewichtsmessung

8.2.1 Grundprinzip
8.2.2 Schaltungsaufbau
8.2.3 Code

Daniel Schauer - nur als Muster  55
9 Entwicklungstools

9.1 Autodesk Fushion

9.2 Eagle

9.3 VS-Code

Visual Studio Code (VS-Code) ist eine kostenlose IDE (integrated development environ-
ment) entwickelt von Microsoft. VS-Code funktioniert auch auf anderen Betriebssyste-
men wie zum Beispiel Windows, Linux oder macOS. VS-Code unterstützt einen Großteil
der Programmiersprachen und kann durch Extentions mit vielen nützlichen Features und
Sprachen immer wieder erweitert werden.2

9.3.1 Setup
Um ein Projekt in VS-Code erstellen zu können, müssen einige Schritte befolgt werden.
Zuallererst muss die IDE von https://code.visualstudio.com/ für das jeweilig passende Be-
triebssystem heruntergeladen und installiert werden. Um Mikrocontroller wie ESPs oder
Arduinos in VS-Code programmieren zu können, wird die PlatformIO IDE Extension be-
nötigt. Um die PlatformIO IDE Extension in VS-Code zu installieren, drückt man einfach
auf das Extensions Symbol oder drückt die Tastenkombination Ctrl+Shift+X um das Ex-
tensions Menü zu öffnen. Danach gibt man in der Suchleiste “PlatformIO IDE“ ein und
wählt die Extension mit der Ameise als Icon. Dann drückt man auf “Install“ und wartet,
bis die Extension fertig heruntergeladen ist. Nach der Installation sollte das PlatformIO
Icon (Ameisenkopf) auf der linken Seite unter dem Extension Menü erscheinen.

Um nun ein neues Projekt zu erstellen, klickt man auf das PlatformIO Icon und wählt “+
New Project“.

Im Project Wizard wählt man nun den gewünschten Namen, das Board, das Framework
als auch den Speicherungsort des Projektes. Bei unserem Projekt wählten wir das Board
“Espressif ESP32 Dev Module“ und als Framework “Arduino“, da wir einen EPS32 zum
Programmieren verwendeten.

    2https://code.visualstudio.com/

Daniel Schauer - nur als Muster  56
9.3.2 Bibliotheken

Bibliotheken sind ein weiterer wichtiger Bestandteil für das Programmieren. Bibliotheken
beinhalten bereits eine Sammlung von vorgefertigtem Code, der für bestimmte Aufgaben,
wie zum Beispiel zum Auswerten eines Sensors, verwendet werden kann. Bibliotheken
werden verwendet, um den Code zu minimieren und dadurch die Lesbarkeit sowie die
Effizienz zu steigern. Um eine Bibliothek für PlatformIO in VS-Code zu installieren, muss
das PIO Home Menü geöffnet werden. Darin befindet sich der Reiter „Libraries“. Wenn
dieses geöffnet wird, erscheint eine Suchleiste, mit der die gewünschten Bibliotheken zum
Projekt hinzugefügt werden können.

9.3.3 verwendete Bibliotheken

ESPAsyncWebServer

Die ESPAsnycWebServer Bibliothek ermöglicht es, Webanwendungen effizient und mit
hoher Performance auf ESP8266- und ESP32 Mikrocontroller zu hosten. Der Asynchro-
ne Betrieb verhindert Blockierungen und sorgt für eine flüssige Verarbeitung mehrere
Anfragen gleichzeitig. Außerdem unterstützt die Bibliothek WebSockets, welche für die
Echtzeitkommunikation zwischen Client und Server benötigt wurden. Die Bibliothek ist
eine leistungsfähigere Alternative zur klassischen WebServer-Bibliothek, da sie ressour-
censchonender und nicht blockieren arbeitet.3

ArduinoJSON

Die ArduinoJson Bibliothek ermöglicht die Verarbeitung von JSON-String in Objekte
und umgekehrt. Sie ist speziell für Geräte mit begrenztem Speicher und Rechenleistung
optimiert. Die Bibliothek wird benötigt, um die erhaltenen Steuerbefehle am ESp32 zu
konvertieren und um sie anschließend weiterzuverarbeiten.4

HCSR04

arduinoWebSockets

Die WebSockets Bibliothek ermöglicht eine Kommunikation über das WebSocket Pro-
tokoll für Arduino-Boards, ESP8266 und ESP32. Die Bibliothek wird für die Echtzeit-
Kommunikation zwischen dem Webserver und den ESP32 benötigt. Außerdem werden
die Bilder der ESp32-CAM über einen WebSocket an den Webserver gesendet. Die Bi-
bliothek ist eine großartige Ergänzung zur ESPAsyncWebServer Bibliothek.5

    3https://github.com/lacamera/ESPAsyncWebServer
    4https://arduinojson.org/
    5https://github.com/Links2004/arduinoWebSockets

Daniel Schauer - nur als Muster  57
ESp32Servo
Adafruit_MCP23x17
HX711_ADC

9.4 LaTex
9.5 GitHub

Daniel Schauer - nur als Muster  58
10 Abbildungsverzeichnis

Abbildungsverzeichnis

    1 Porträt Daniel Schauer . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
    2 Porträt Simon Spari . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
    3 Porträt Felix Hochegger . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
    4 Motoren . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
    5 BLDC-Motor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
    6 Phasensteuerung . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
    7 Motorteiber-ZS-X11H . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
    8 Motorphasen Verbindung . . . . . . . . . . . . . . . . . . . . . . . . . . 15
    9 Pins für die PWM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
    10 Pin für die Bremse und den Richtungswechsel . . . . . . . . . . . . . . . 16
    11 Versorgungs-Pins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
    12 Hall-sensoren Eingänge . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
    13 ESPAsyncWebServer.h-Bibliothek . . . . . . . . . . . . . . . . . . . . 19
    14 WebServer Netzwerkkonfiguration . . . . . . . . . . . . . . . . . . . . . 19
    15 Webserver Setup . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
    16 SPIFFS Initalisierung . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
    17 readfile()-Funktion . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
    18 Bibliotheken für die Kommunikation . . . . . . . . . . . . . . . . . . . . 22
    19 Netzwerkkonfiguration Client . . . . . . . . . . . . . . . . . . . . . . . 23
    20 Setup ESP32 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
    21 onWebSocketEvent()-Funktion . . . . . . . . . . . . . . . . . . . . . . 25
    22 JSON-Beispiel für Steuerung . . . . . . . . . . . . . . . . . . . . . . . . 25
    23 JSON-Beispiel für Kamerasteuerung . . . . . . . . . . . . . . . . . . . . 26
    24 JSON-Beispiel für Lichtsteuerung . . . . . . . . . . . . . . . . . . . . . 26
    25 handleWebSocketMessage()-Funktion . . . . . . . . . . . . . . . . . . 27
    26 Kamera-GPIO Konfiguration . . . . . . . . . . . . . . . . . . . . . . . . 28
    27 Kamera-Initialisierung . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
    28 Videoübertragung über WebSocket . . . . . . . . . . . . . . . . . . . . . 30
    29 Steuerkreuz auf der Website . . . . . . . . . . . . . . . . . . . . . . . . 31
    30 Steuerkreuz HTML-Code . . . . . . . . . . . . . . . . . . . . . . . . . . 31
    31 CSS-Klassen .dpad-container und .button . . . . . . . . . . . . . . 32
    32 CSS-Richtungsklassen . . . . . . . . . . . . . . . . . . . . . . . . . . . 33

Daniel Schauer - nur als Muster  59
33 <hier gute Bildbeschreibung einfügen> . . . . . . . . . . . . . . . . . . . 34
34 <hier gute Bildbeschreibung einfügen> . . . . . . . . . . . . . . . . . . . 34
35 send()-Funktion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
36 stop()-Funktion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
37 Geschwindigkeitssteuerung auf der Website . . . . . . . . . . . . . . . . 36
38 Geschwindigkeitssteuerung HTML-Code . . . . . . . . . . . . . . . . . 37
39 CSS-Klassen für die Geschwindigkeitssteuerung . . . . . . . . . . . . . 37
40 speed-change()-Funktion . . . . . . . . . . . . . . . . . . . . . . . . . 38
41 Kamerasteuerung auf der Website . . . . . . . . . . . . . . . . . . . . . 38
42 Kamerasteuerung HTML-Code . . . . . . . . . . . . . . . . . . . . . . . 39
43 CSS-Klassen für die Kamerasteuerung . . . . . . . . . . . . . . . . . . . 39
44 camera-change()-Funktion . . . . . . . . . . . . . . . . . . . . . . . . 40
45 Fernlicht-Icon auf der Website . . . . . . . . . . . . . . . . . . . . . . . 40
46 HTML-Code für Fernlicht . . . . . . . . . . . . . . . . . . . . . . . . . 41
47 CSS-Klassen für das Fernlicht . . . . . . . . . . . . . . . . . . . . . . . 41
48 togglelight()-Funktion . . . . . . . . . . . . . . . . . . . . . . . . . 42
49 Videoübertragung auf der Website . . . . . . . . . . . . . . . . . . . . . 43
50 Videoübertragung HTML-Code . . . . . . . . . . . . . . . . . . . . . . 43
51 CSS-Formatierung für dynamicimage . . . . . . . . . . . . . . . . . . . 43
52 Videoübertragung im JavaScript-Code . . . . . . . . . . . . . . . . . . . 44
53 Menü-Icon auf der Website . . . . . . . . . . . . . . . . . . . . . . . . . 45
54 Sidebar mit Sensordaten . . . . . . . . . . . . . . . . . . . . . . . . . . 45
55 Sensordaten HTML-Code . . . . . . . . . . . . . . . . . . . . . . . . . . 46
56 CSS-Klassen für das Menü . . . . . . . . . . . . . . . . . . . . . . . . . 47
57 CSS-Klasse .daten . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
58 JavaScript-Verarbeitung der Sensordaten . . . . . . . . . . . . . . . . . . 48
59 Statusbox auf der Website . . . . . . . . . . . . . . . . . . . . . . . . . . 49
60 Statusbox: Verbunden . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
61 Statusbox: Verbindung getrennt . . . . . . . . . . . . . . . . . . . . . . . 49
62 Statusbox HTML-Code . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
63 CSS-Klassen für die Statusbox . . . . . . . . . . . . . . . . . . . . . . . 50
64 JavaScript Funktionen für den Verbindungsstatus . . . . . . . . . . . . . 50

Daniel Schauer - nur als Muster  60
11 Literaturverzeichnis

Daniel Schauer - nur als Muster  61

