\documentclass[ngerman,12pt,a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{amssymb}
\usepackage{nameref}
\usepackage{babel}
\usepackage{hyperref}
\usepackage{titlesec}
\usepackage[a4paper, left=3cm, right=3cm, top=3cm, bottom=3cm]{geometry}
\usepackage{setspace}
\onehalfspacing
\usepackage{mathptmx}
\usepackage{array}
\usepackage{booktabs}
\usepackage{adjustbox}
\usepackage{longtable}
\pagestyle{fancy}
\fancyhf{}
\fancyfoot[R]{\thepage}
\titleformat{\section}{\Huge\bfseries}{\thesection}{1em}{}
\title{\textbf{\Huge Diplomarbeit: \\ Lastenroboter}}
\date{}
\begin{document}
	\maketitle
	\begin{center}
		\textbf{Höhere Technische Bundeslehranstalt Graz Gösting}\\
		\textbf{Schuljahr 2024/25}\\[0.5 cm]
		\includegraphics[scale=0.5]{Pictures/bulme_logo}\\[1 cm]
		\begin{tabular}{l l l}
			\textbf{Diplomanden:} & & \textbf{Betreuer:} \\
			Daniel Schauer & 5AHEL & Prof. DI. Gernot Mörtl \\
			Simon Spari & 5AHEL & \\
			Felix Hochegger & 5AHEL & \\
		\end{tabular}
	\end{center}
	\newpage
	\begin{flushleft}
		\textbf{\Huge Eidesstattliche Erklärung}\\[0.5 cm]
	\end{flushleft}
	Wir erklären an Eides statt, dass wir die vorliegende Diplomarbeit selbstständig und ohne fremde Hilfe verfasst, keine anderen als die angegebenen Quellen und Hilfsmittel benutzt und die den benutzten Quellen wörtlich und inhaltlich entnommenen Stellen als solche erkenntlich gemacht haben. 
	\vspace{2cm}
	
	\noindent
	\begin{tabular}{p{7cm} p{7cm}}
		\hrulefill & \hrulefill \\
		Ort, am TT.MM.JJJJ & Daniel Schauer \\
	\end{tabular}
	
	\vspace{2cm}
	
	\noindent
	\begin{tabular}{p{7cm} p{7cm}}
		& \hrulefill \\
		& Simon Spari \\
	\end{tabular}

	\vspace{2cm}
	\noindent
	\begin{tabular}{p{7cm} p{7cm}}
		& \hrulefill \\
		& Felix Hochegger \\
	\end{tabular}
	\newpage
	\textbf{\Huge Danksagung}\\[0.5 cm]
	An dieser Stelle möchten wir unseren aufrichtigen Dank aussprechen.\\[0.5 cm]
	Ein besonderer Dank gilt Herrn Prof. DI Gernot Mörtl für seine wertvolle Unterstützung, seine fachliche Begleitung und seine konstruktiven Anregungen während der gesamten Arbeit. Seine Expertise und sein Engagement haben maßgeblich zum Gelingen dieser Diplomarbeit beigetragen.\\[0.5 cm]
	Ebenso danken wir unseren Freunden, insbesondere Michael Johannes Anderhuber, für seine Unterstützung beim Schweißen des Gehäuses. Sein handwerkliches Geschick und seine Hilfe waren für die Umsetzung unseres Projekts von großem Wert.\\[0.5 cm]
	Unser großer Dank gilt zudem unserem großzügigen Sponsor,"Vogl Baumarkt Rosental", für das Sponsoring des Metalls für das Gehäuse. Durch diese Unterstützung konnten wir unser Projekt in dieser Form verwirklichen.
	\newpage
	\tableofcontents
	\newpage
	\section{Einleitung}
	\subsection{Kurzzusammenfassung}
	In dieser Diplomarbeit wird ein Lastenroboter entwickelt, der bis zu 25 Kilogramm transportieren kann. Der Roboter wird über eine Website gesteuert, die als Steuerungsplattform dient. Zusätzlich ist eine Kamera eingebaut, die den Transportbereich zeigt, sowie eine Waage, die das Gewicht der transportierten Last misst.\\[0.5 cm]
	Ein Schwerpunkt der Arbeit lieg auf der mechanischen Konstruktion des Roboters, bei der ein stabiles Gehäuse aus Stahl gebaut wird, um Sicherheit und Stabilität zu gewährleisten. Außerdem wird eine eigene Platine entwickelt, die die verschiedenen Hardware-Komponenten, wie die Sensoren und die Motoren, steuert und miteinander verbindet.\\[0.5 cm]
	Die Steuerung des Roboters erfolgt über eine Website, die es dem Benutzer ermöglicht, den Roboter zu bedienen und wichtige Daten wie Akkustand und Gewicht abzurufen. Ein besonderer Fokus liegt auch dabei auf der Übertragung des Kamerabildes auf die Web-Oberfläche sowie der Integration einer schwenkbaren Kamera, um eine flexible Sicht auf den Transportbereich zu gewährleisten. Der ESP32 sorgt dafür, dass die Befehle des Benutzers an den Roboter übermittelt werden.\\[0.5 cm]
	Zusätzlich wird eine OnBoard-Software entwickelt, die es ermöglicht, die Sensoren auszulesen und die Motoren als auch die Kamera anzusteuern.\\[0.5 cm]
	\subsection{Abstract}
	This thesis develops a load robot that can carry up to 25 kilograms. The robot is controlled via a website, which serves as the control platform. Additionally, a camera is integrated to display the transport area, as well as a scale to measure the weight of the carried load.\\[0.5 cm]
	A key focus of the work is on the mechanical design of the robot, where a sturdy steel housing is built to ensure safety and stability. Furthermore, a custom circuit board is developed to control and connect the various hardware components, such as sensors and motors.\\[0.5 cm]
	The robot is controlled via a website, which allows the user to operate the robot and access important data such as battery level and weight. A particular focus is also placed on transferring the camera feed to the web interface and integrating a swivel camera to ensure flexible viewing of the transport area. The ESP32 ensures that the user's commands are transmitted to the robot.\\[0.5 cm]
	Additionally, onboard software is developed to read the sensors and control the motors and camera.
	%Namen links unten als muster für später
	\fancyfoot[L]{Daniel Schauer - nur als Muster}
	\thispagestyle{fancy}
	\newpage
	\section{Projektmanagement}
	
		\subsection{Projektteam} %Daniel
		
		\subsection{Projektstrukturplan} %Daniel
		
		\subsection{Meilensteine} %Daniel
		
		\subsection{Kostenaufstellung} %Daniel
	
	\section{Antrieb}
	
		\subsection{Motoren} %Felix
		
		\subsection{Motorentreiber} %Felix
		
		\subsection{Schaltungsaufbau} %Felix
		
		\subsection{Code} %Daniel
	
	\section{Webserver} %Spari
	 
		\subsection{Grundlegende Ziele}
	In diesem Kapitel befassen wir uns mit der geplanten Website, die den Benutzern und Benutzerinnen die Steuerung des Lastenroboters ermöglichen soll. Zuallererst definieren wir die grundlegenden Funktionen, die die Website erfüllen soll. Sobald diese erfüllt sind, versuchen wir, das User Interface so einfach und benutzerfreundlich wie möglich zu gestalten. Ein weiterer Punkt ist die Darstellung der spezifischen Messwerte und Daten, damit diese am Webserver schnell und leicht zugänglich sind.\\[0.5cm]
	Für die Entwicklung der Website verwenden wir HTML, CSS und JavaScript, um alle funktionalen und optischen Anforderungen zu erfüllen.  
	
			\subsubsection*{Videoübertragung} 	 
	
	Auf der Website soll eine Echtzeit Videoübertragung der ESP32-CAM angezeigt werden. Die Bildfrequenz und die Qualität der Videoübertragung sollte ausgeglichen sein, so dass in der Übertragung alle Objekte und ggf. Hindernisse frühzeitig erkennbar sind und noch Reaktionszeit zum Manövrieren besteht. 
	
			\subsubsection*{Steuerung}
	
	Auf der Website soll eine grafische Steuereinheit implementiert werden, mit der der Roboter gesteuert und navigiert werden kann. Diese soll dann die entsprechenden Steuerbefehle bzw. Richtungen an den ESP32 senden, wo sie dann in Steuerungsbefehle für die Motoren übersetzt werden.  
	
			\subsubsection*{Anzeigen von Daten}
	
	Auf der Website sollen bestimmte Messwerte und Daten, wie zum Beispiel Akkustand oder zurzeit aufliegende Last, die vom ESP32 durch Sensoren oder Messungen ausgewertet werden, übersichtlich und leicht zugänglich angezeigt werden.
	
		\subsection{Ideen und Entwürfe}
		
		\subsection{Webserver}
		
			\subsubsection{Webserver Setup}
			
	Der Webserver wird mithilfe der Bibliothek ESPAsyncWebServer auf einem ESP32-CAM Mikrocontroller eingerichtet. Diese Bibliothek ermöglicht einen nicht-blockierenden Betrieb, wodurch parallele Anfragen effizient verarbeitet werden können.\footnote{https://github.com/lacamera/ESPAsyncWebServer} \\[0.5cm]
	Für die Netzwerkkonfiguration wurde ein eigener Access Point mit folgenden Parametern definiert:
	
	\begin{itemize}
		\item SSID (Service Set Identifiert) : “Carybot” – dient zur Identifikation des drahtlosen Netwerkes
		\item Passwort: “123456789“ – dient zum Schutz des Netwerkes
		\item Lokale IP-Adresse: 192.168.4.1 – dient zum Zugriff auf die Webserver-Oberfläche
		\item Gateway-Adresse: 192.168.4.1 - ESP32-CAM fungiert als Access Point
		\item Subnetzmaske: 255.255.255.0 - ermöglicht die Kommunikation zwischen Geräten im Bereich 192.168.4.x
	\end{itemize} 
	Der Webserver wird auf Port 80 erstellt. Port 80 ist der Standardport für HTTP-Dienste. 
	\\[0.5cm]
	In der Setup Funktion wird danach überprüft, ob der Access Point erfolgreich konfiguriert worden ist und ob der Access Point erfolgreich gestartet werden kann. Falls ein Fehler auftreten sollte, wird der Setup unterbrochen und die jeweilige Fehlermeldung in der seriellen Konsole ausgegeben. Wenn alles erfolgreich konfiguriert ist und starten kann, wird im Seriellen Monitor die IP-Adresse in der seriellen Konsole ausgegeben. Anschließend wird der Webserver gestartet.
			
			\subsubsection{SPIFFS Setup}
			
	SPIFFS (SPI Flash File System) ist ein leichtgewichtiges Dateisystem für Mikrocontroller mit SPI-Flash-Speicher. Es ermöglicht das Speichern und Verwalten von Dateien direkt im Flash-Speicher des Mikrocontrollers. SPIFFS wird in unserem Projekt benötigt, um statische Dateien für unseren Webserver (HTML-, CSS-, JavaScript Anwendungen) bereitzustellen. \\[0.5cm] 
	In unserem Code wird zuallererst einmal überprüft, ob SPIFFS beim Start der ESP32-CAM richtig initialisiert werden kann. Falls es fehlschlägt, wird eine Fehlermeldung in der seriellen Konsole ausgegeben und das Programm gestoppt. Ansonsten werden die Webserver-Endpunkte über HTTP-GET-Routen definiert, über die unsere statischen Dateien aus SPIFFS an Clients gesendet werden. \\[0.5cm] 
	“/“ ist die Standardroute des Servers. Somit wird dpad.html als Startseite angezeigt, wenn ein Client sich verbindet. \\[0.5cm] 
	“menu-icon.svg“ und “Fernlicht.svg“ werden als SVG-Bilder (Scalable Vector Graphics) an den Browser gesendet. Image/svg+xml sorgt dafür, dass der Browser die Dateien als SVG-Bilder erkennt. \\[0.5cm] 
	“mystyles.css“ wird mit text/css als CSS-Datei gesendet und dient zur Formatierung der Website. \\[0.5cm] 
	“carybot.js“ wird mit application/javascript als Javascript-Datei gesendet und verarbeitet die Eingaben von Clients auf der Website. \\[0.5cm] 
	Wenn alle Dateien erfolgreich geladen sind, wird eine Nachricht in der seriellen Konsole ausgegeben. \\[0.5cm] 
	Die readFile() Funktion wird benötigt, um die jeweiligen Dateien aus SPIFFS lesen zu können. Die Funktion liest eine Datei aus dem SPIFFS-Speicher und gibt den Inhalt als String zurück.
			
	\begin{figure}[h]
		\centering
		\includegraphics{Pictures/SPIFFS\_setup}
		\caption{SPIFFS Initalisierung}
		\label{fig:spiffs_init}
		\par\small Quelle: eigene Abbildung
	\end{figure}	
	
			
		\subsection{WebSocket Kommunikation}
		
			\subsubsection{Kommunikation Setup}	
			
	Für die Kommunikation zwischen dem Webserver und dem ESP32 wird die ArduinoJson und die ArduinoWebSockets Bibliothek benötigt. Die ArduinoJson Bibliothek wird für die Umwandlung der JSON-Steuerbefehle benötigt. Die ArduinoWebSockets Bibliothek wird für die Kommunikation über das WebSocket Protokoll benötigt. \\[0.5cm]
	Für die Netzwerkkonfiguration als Client werden folgenden Parameter definiert:
	\begin{itemize}
		\item SSID: “Carybot“ – gleiche SSID wie ESP32-CAM
		\item Passwort: “123456789“ – gleiches Passwort wie ESP32-CAM
		\item Lokale IP-Adresse: 192.168.4.3 
		\item Gateway-Adresse: 192.168.4.1 – Adresse des Access Points (ESP32-CAM)
		\item Subnetzmaske: 255.255.255.0 – ermöglicht Kommunikation zwischen Geräten im Bereich 192.168.4.x
	\end{itemize}
	Für die WebSocket-Kommunkation wurde der Port 8080 gewählt. \\[0.5cm]
	In der Setup Funktion des Programmes wird dann überprüft, ob die IP-Konfiguration erfolgreich abgeschlossen wurde. Ansonsten kommt es zu einer Fehlermeldung und das Setup wird abgebrochen. Danach wird versucht, sich mit dem WLAN-Netzwerk zu verbinden. Wenn sich der ESP32 erfolgreich mit dem WLAN verbunden hat, wird eine Nachricht und die IP-Adresse des ESP32 in der seriellen Konsole ausgegeben. Danach wird die WebSocket Konfiguration noch gestartet. Es wird definiert, dass die Funktion onWebSocketEvent aufgerufen wird, wenn Events über den WebSocket registriert werden. In der loop Funktion wird dann noch ständig überprüft, ob neue Events am WebSocket registriert werden.
			
			\subsubsection{Message Handling}
			
	In der Funktion onWebSocketEvent() werden die WebSocket-Ereignisse verarbeitet. Sie wird aufgerufen, wenn sich ein WebSocket-Client verbindent, eine Nachricht sendet oder die Verbindung sich trennt.
	Der Parameter num steht für die ID des Clients, der das Event ausgelöst hat. Der Parameter type gibt die Art des WebSocket-Event an. Der Parameter payload sind die empfangenen Daten. Der Parameter length steht für die Größe des payload-Arrays. 
	In der Funktion werden die Events mit einem switch-case verarbeitet\\[0.5cm]
	Übersicht der WebSocket-Ereignisse:
	
	\begin{table}[h]
		\centering
		\renewcommand{\arraystretch}{1.2}
		\setlength{\tabcolsep}{8pt}
		\begin{adjustbox}{max width=\textwidth}
    	\begin{tabular}{|l|p{5cm}|p{6cm}|}

		\hline
		\textbf{Ereignistyp} & \textbf{Beschreibung} & \textbf{Verarbeitung} \\
		\hline
		WStype\_CONNECTED & Ein neuer Client verbindet sich. & Ausgabe der Client-ID \& IP-Adresse in der Konsole \\
		\hline
		WStype\_TEXT & Eine Textnachricht wird empfangen. & Übergabe an \texttt{handleWebSocketMessage()} \\
		\hline
		WStype\_BIN & Binärdaten werden empfangen. & Nachricht in der Konsole (wird nicht verarbeitet) \\
		\hline
		WStype\_DISCONNECTED & Ein Client trennt die Verbindung. & Meldung mit der Client-ID in der Konsole. \\
		\hline
	
		\end{tabular}
		\end{adjustbox}
		\caption{Übersicht der WebSocket-Ereignisse}
		\label{tab:websocket-events}
	\end{table} 
	Die Funktion handleWebSocketMessage() verarbeitet die WebSocket-Nachricht, die als JSON-Objekte gesendet werden. Die Parameter sind wieder die Client-ID, die empfangenen Nachricht und die Länge der empfangenen Nachricht. \\[0.5cm]
	Zuerst wird die empfangene Nachricht (payload) in einen String konvertiert. Diese wird dann in der seriellen Konsole ausgegeben. Danach wird ein JSON-Dokument mit max 200 Bytes erstellt. Die empfangene Nachricht wird dann mit deserialzeJson() geparst. Falls das Parsen erfolgreich war, wird die JSON-Nachricht verarbeitet. \\[0.5cm]
	Wenn die JSON-Nachricht den Namen \texttt{robot\_direction} enthält, wird die Richtung mit der Funktion \texttt{stringToDirection()} in eine eigene Variable umgewandelt. Auch die mitgesendete Variable \texttt{speed} wird ebenfalls in eine eigene Variable gespeichert. \\[0.5cm]
	Wenn die JSON-Nachricht den Namen \texttt{camera\_position} enthält, wird der Wert der Nachricht in die Variable \texttt{camera\_pos} gespeichert und die Funktion \texttt{cam\_turn()}  aufgerufen. \\[0.5cm]
	Wenn die JSON-Nachricht den Namen \texttt{light\_status} enthält, wird der Wert der Nachricht in die boolesche Variable \texttt{light\_status}  gespeichert. Dieser Variable wird dann in die numerische Variable \texttt{light\_st} umgewandelt (1 = an, 0 = aus). Wenn \texttt{light\_st} eine 1 ist, wird die Funktion \texttt{lights\_on(}) aufgerufen, ansonsten wird die Funktion \texttt{lights\_off()} aufgerufen.
			
		\subsection{Kamera}
		
			\subsubsection{Kamera Setup}
			
	Um die Kamera programmieren zu können, muss zunächst das richtige Board \texttt{AI Thinker ESP32-CAM} ausgewählt werden. Danach müssen die ESP32-Kamera-Treiber mit der Bibliothek \texttt{esp\_camera.h} inkludiert werden. Dann muss das passende ESP32-CAM-Modell festgelegt werden. Da wir uns für das \texttt{Ai-Thinker} Modell entschieden haben, muss diese nun definiert werden. Falls ein anderes Modell genutzt wird, muss es entsprechend angepasst werden. \\[0.5cm]
	Als nächstes werden die GPIO-Pins der ESP32-CAM für die Kamera OV2640 konfiguriert. Diese Zuordnung ist spezifisch für das Ai-Thinker-Modell und muss für jedes Modell individuell angepasst werden. \\[0.5cm]
	Als nächstes muss die ESP32-CAM mit der ESP-IDF \texttt{esp\_camera} Bibliothek konfiguriert und initialisiert werden. Als erstes muss mit \texttt{camera\_config\_t} eine Struktur definiert werden, mit der verschiedene Parameter und Eigenschaften wie GPIO-Pins, Bildgröße und Qualität festlegt werden können. \\[0.5cm] 
	LEDC-Kanal und Timer werden für das Taktsignal benötigt, um die Kamera zu betreiben.
		
			\subsection{Videoübertragung}
			
	In unserem Projekt werden die Live-Bilder per WebSocket an den Webserver gesendet. Um dies umzusetzen, wird zuerst eine Webserver-Route benötigt. Dazu wird eine http-GET-Anfrage für die Hauptseite (“/“) definiert. Im Code wird ein JavaScript Skript benutzt, um eine Websocket-Verbindung herzustellen. Die IP-Adresse wird automatisch durch \texttt{windows.location.hostname} erkannt. Port 81 wird für das WebSocket-Streaming verwendet. Wenn die ESP32-CAM ein neues Bild als WebSocket-Nachricht versendet, wird es als JPEG-Blob gespeichert. Danach wird ein temporär URL-Link erstellt. Das Bild wird schlussendlich in einem \texttt{<img>}-Tag mit der id \texttt{stream} angezeigt. \\[0.5cm]
	Die WebSocket Verbindung wird die ganze Zeit überwacht. In der Konsole wird ausgegeben, wenn die Websocket-Verbindung aktiv ist. Falls die Verbindung abbrechen sollte, wird nach 5 Sekunden automatisch ein erneuter Verbindungsversuch gestartet. Zum Schluss wird der HTML-Code mit \texttt{HTTP-Status 200} (OK) an den Browser gesendet. 
	
			
		\subsection{Website}

			\subsubsection{Implementierung der Steuerung}
			
			\subsubsection{Echtzeit-Videoanzeige}
			
			\subsubsection{Anzeige von Sensordaten und Systemstatus}			
			
		\subsection{Herausforderungen und Optimierungen}
		
			\subsubsection{Probleme bei der WebSocket Kommunikation}
			
			\subsubsection{Latenz- und Performance Optimierungen}
			
			\subsubsection{(Speicher- und Rechenleistungseinschränkungen des ESP32)}
		\newpage
					
		\subsection{(Fazit und Ausblick)}
		
			\subsubsection{(Mögliche Erweiterungen und Verbesserungen)}
	
	\section{Gehäuse}
	
		\subsection{Planung und Design} %Felix
		
		\subsection{Realisierung} %Felix
	
		\subsection{Materialliste} %Felix
	
	\section{Platine}
	
		\subsection{Grundschaltung} %Felix
		
		\subsection{Circuit Board} %Felix
		
		\subsection{Fertiger Prototyp} %Felix
	
	
	\section{Kamera}
	
		\subsection{Kamera im Überblick} %Daniel
		
		\subsection{Videoübertragung} %Simon
		
		\subsection{Kameraschwenkung} %Felix
		
			\subsubsection{Gehäuse} %Felix
			
			\subsubsection{Servomotor} %Daniel
	
		\subsection{Code} %Daniel und %Simon
		
\newpage
	\section{Sensoren}
	
		\subsection{Abstandsensor} %Daniel
		
		\subsection{Gewichtsmessung}
		
			\subsubsection{Grundprinzip} %Daniel
		
			\subsubsection{Schaltungsaufbau} %Daniel
		
			\subsubsection{Code} %Daniel
	
	
	\section{Entwicklungstools}
	
	 \subsection{Autodesk Fushion}
	 
	 \subsection{Eagle}
	 	 
	 \subsection{VS-Code}
	 
	 Visual Studio Code (VS-Code) ist eine kostenlose IDE (integrated development environment) entwickelt von Microsoft. VS-Code funktioniert auch auf anderen Betriebssystemen wie zum Beispiel Windows, Linux oder macOS. VS-Code unterstützt einen Großteil der Programmiersprachen und kann durch Extentions mit vielen nützlichen Features und Sprachen immer wieder erweitert werden.\footnote{https://code.visualstudio.com/}
	 	
	 	\subsubsection{Setup}
	 	
	 Um ein Projekt in VS-Code erstellen zu können, müssen einige Schritte befolgt werden. Zuallererst muss die IDE von https://code.visualstudio.com/ für das jeweilig passende Betriebssystem heruntergeladen und installiert werden. Um Mikrocontroller wie ESPs oder Arduinos in VS-Code programmieren zu können, wird die PlatformIO IDE Extension benötigt. Um die PlatformIO IDE Extension in VS-Code zu installieren, drückt man einfach auf das Extensions Symbol oder drückt die Tastenkombination Ctrl+Shift+X um das Extensions Menü zu öffnen. Danach gibt man in der Suchleiste “PlatformIO IDE“ ein und wählt die Extension mit der Ameise als Icon. Dann drückt man auf “Install“ und wartet, bis die Extension fertig heruntergeladen ist. Nach der Installation sollte das PlatformIO Icon (Ameisenkopf) auf der linken Seite unter dem Extension Menü erscheinen. \\[0.5cm]
	 Um nun ein neues Projekt zu erstellen, klickt man auf das PlatformIO Icon und wählt “+ New Project“. \\[0.5cm]
	 Im Project Wizard wählt man nun den gewünschten Namen, das Board, das Framework als auch den Speicherungsort des Projektes. Bei unserem Projekt wählten wir das Board “Espressif ESP32 Dev Module“ und als Framework “Arduino“, da wir einen EPS32 zum Programmieren verwendeten. \\[0.5cm]
	 	
	 	
	 	\subsubsection{Bibliotheken}
	 	
	 Bibliotheken sind ein weiterer wichtiger Bestandteil für das Programmieren. Bibliotheken beinhalten bereits eine Sammlung von vorgefertigtem Code, der für bestimmte Aufgaben, wie zum Beispiel zum Auswerten eines Sensors, verwendet werden kann. Bibliotheken werden verwendet, um den Code zu minimieren und dadurch die Lesbarkeit sowie die Effizienz zu steigern. Um eine Bibliothek für PlatformIO in VS-Code zu installieren, muss das PIO Home Menü geöffnet werden. Darin befindet sich der Reiter „Libraries“. Wenn dieses geöffnet wird, erscheint eine Suchleiste, mit der die gewünschten Bibliotheken zum Projekt hinzugefügt werden können.
	 
		\subsubsection{verwendete Bibliotheken}
		
			\subsubsection*{ESPAsyncWebServer}
			
	Die ESPAsnycWebServer Bibliothek ermöglicht es, Webanwendungen effizient und mit hoher Performance auf ESP8266- und ESP32 Mikrocontroller zu hosten. Der Asynchrone Betrieb verhindert Blockierungen und sorgt für eine flüssige Verarbeitung mehrere Anfragen gleichzeitig. Außerdem unterstützt die Bibliothek WebSockets, welche für die Echtzeitkommunikation zwischen Client und Server benötigt wurden. Die Bibliothek ist eine leistungsfähigere Alternative zur klassischen WebServer-Bibliothek, da sie ressourcenschonender und nicht blockieren arbeitet.\footnote{https://github.com/lacamera/ESPAsyncWebServer}
	
			\subsubsection*{ArduinoJSON}
			
	Die ArduinoJson Bibliothek ermöglicht die Verarbeitung von JSON-String in Objekte und umgekehrt. Sie ist speziell für Geräte mit begrenztem Speicher und Rechenleistung optimiert. Die Bibliothek wird benötigt, um die erhaltenen Steuerbefehle am ESp32 zu konvertieren und um sie anschließend weiterzuverarbeiten.\footnote{https://arduinojson.org/}
			
			\subsubsection*{HCSR04}
			
			\subsubsection*{arduinoWebSockets}
			
	Die WebSockets Bibliothek ermöglicht eine Kommunikation über das WebSocket Protokoll für Arduino-Boards, ESP8266 und ESP32. Die Bibliothek wird für die Echtzeit-Kommunikation zwischen dem Webserver und den ESP32 benötigt. Außerdem werden die Bilder der ESp32-CAM über einen WebSocket an den Webserver gesendet. Die Bibliothek ist eine großartige Ergänzung zur ESPAsyncWebServer Bibliothek.\footnote{https://github.com/Links2004/arduinoWebSockets}
			
			\subsubsection*{ESp32Servo}
			
			\subsubsection*{Adafruit\_MCP23x17}
			
			\subsubsection*{HX711\_ADC}
				
	 \subsection{LaTex}
	 
	 \subsection{GitHub}
	
	\section{Abbildungsverzeichnis}
	
		\listoffigures
	
	\section{Literaturverzeichnis}
	 
\end{document}